#include <stdio.h> // библиотека для ввода и вывода
#include <stdlib.h> // для работы с динамической памятью и вызова функции system

/*
 * фукнция для сортировки матрицы
 */
void* sortMatrix(int** matrix, int ROWS, int COLUMNS);

/*
 * функция для вставки нового элемента в матрицу
 */
void* addElement(int** matrix, int ROWS, int *COLUMNS, int NEW_ELEMENT);

/*
 * функция для подсчёта суммы элементов по диагонали матрицы
 */
int* countDiagonalSum(int** matrix, int ROWS, int COLUMNS);

int main()
{
	int m; // количество строк
	int n; // количество столбцов
	
	printf("Enter the number of rows and columns of the matrix:\n");
	
	/*
	 * считываем число m и n с клавиатуры(количество строк и столбцов)
	 */
	scanf_s("%d", &m);
	scanf_s("%d", &n);
	printf("\n");

	/*
	 * создаем изначальную матрицу при помощи
	 * двумерного массива с выделением динамической памяти
	 */
	int** matrix = (int**)malloc(m * sizeof(int*));
	for (int i = 0; i < m; i++) {
		matrix[i] = (int*)malloc((n + 1) * sizeof(int));
	}
	
	printf("Enter the matrix elements:\n");

	/*
	 * заполняем нашу матрицу элементами
	 */
	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
		{
			scanf_s("%d", &matrix[i][j]);
		}
	}
	printf("\n\n");

	/*
	 * производим первую сортировку для нашей изначальной матрицы
	 */
	sortMatrix(matrix, m, n);
	
	printf("Sorted matrix:\n");
	printf("--------------\n");

	/*
	 * выводим на экран полученную отсортированную матрицу
	 */
	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
		{
			printf("%d\t", matrix[i][j]);
		}
		printf("\n");
	}
	printf("\n\n");

	/*
	 * теперь работаем с полученной матрицей и
	 * добавляем новый элемент в каждую строку матрицы
	 */

	int newElement; // новый элемент матрицы, который добавляем в каждую строку
	printf("Enter the item you want to add to each row of the matrix.:\n");
	scanf_s("%d", &newElement);
	printf("\n\n");

	/*
	 * вызываем функцию addElement по добавлению
	 * нового элемента в матрицу
	 *
	 * передаем третьим аргументом адрес
	 * переменной n (столбца), чтобы увеличить
	 * внутри функции addElement количество
	 * столбцов матрицы
	 */
	addElement(matrix, m, &n, newElement);
	
	printf("New matrix:\n");
	printf("-----------\n");
	/*
	 * выводим элементы полученной новой матрицы
	 */
	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
		{
			printf("%d\t", matrix[i][j]);
		}
		printf("\n");
	}
	printf("\n\n");

	/*
	 * подсчитываем сумму элементов по диагонали
	 * матрицы, и если она не квадратная, то в sum
	 * передается пустота(значение NULL)
	 */

	/*
	 * значение NULL может принимать только указатель,
	 * поэтому придется объявить sum как указатель
	 */
	const int* sum = countDiagonalSum(matrix, m, n);

	/*
	 * если сумма была подсчитана, то
	 * выводим на экран полученную сумму
	 */
	if (sum != NULL)
	{
		/*
		 * чтобы вывести на экран значение указателя sum,
		 * используем операцию разименования указателя
		 * (перед sum ставим *)
		 */
		printf("Diagonal sum of elements = %d.", *sum);
		printf("\n\n");
	}

	system("pause");
	return 0;
}

/*
 * сортировка матрицы методом Пузырька(немного измененным,
 * чтобы не сортировать всю матрицу как единую строку)
 */
void* sortMatrix(int** matrix, const int ROWS, const int COLUMNS)
{
	for (int k = 0; k < ROWS; k++)
	{
		/*
		 * так как нам нужно отсортировать каждую строку независимо друг
		 * от друга, то количество вложенных циклов придется увеличить
		 *
		 * вычитаем единицу, чтобы не выйти за пределы массива во время сортировки
		 */
		for (int i = 0; i < COLUMNS - 1; i++)
		{
			for (int j = 0; j < COLUMNS - i - 1; j++)
			{
				/*
				 * если текущий элемент строки матрицы больше
				 * следующего, то меняем их местами
				 */
				if (matrix[k][j] > matrix[k][j + 1])
				{
					const int temp = matrix[k][j];
					matrix[k][j] = matrix[k][j + 1];
					matrix[k][j + 1] = temp;
				}
			}
		}
	}
}

/*
 * функция по добавлению нового элеменента в каждую строку матрицы
 */
void* addElement(int** matrix, const int ROWS, int *COLUMNS, const int NEW_ELEMENT)
{
	/*
	 * добавляем новые элементы в конец каждой строки матрицы
	 */
	for (int i = 0; i < ROWS; i++)
	{
		matrix[i][*COLUMNS] = NEW_ELEMENT;
	}

	/*
	 * увеличиваем количество столбцов в матрице на единицу
	 *
	 * так как делаем это через указатель, то возвращать
	 * новое число столбцов при помощи оператора return
	 * не надо
	 */
	*COLUMNS = *COLUMNS + 1;

	/*
	 * после добавления нового элемента в конец каждой строки
	 * матрицы, мы сортируем нашу матрицу по новой
	 */
	sortMatrix(matrix, ROWS, *COLUMNS);
}

/*
 * функция для подсчёта суммы элементов по диагонали матрицы(если она квадратичная)
 */
int* countDiagonalSum(int** matrix, const int ROWS, const int COLUMNS)
{
	/*
	 * проверяем, чтобы количество строк
	 * и столбцов было одинаковое (то есть
	 * матрица была квадратная)
	 */
	if (ROWS == COLUMNS)
	{
		/*
		* обязательно надо проинициализировать
		* переменную sum как 0, так как мы
		* прибавляем к ней другие значения,
		* а не перезаписываем
		*/
		int sum = 0;
		for (int i = 0; i < ROWS; i++) // можно написать и COLUMNS(разницы не будет)
		{
			/*
			 * все элементы по диагонали имеют
			 * одинаковый номер строки и столбца,
			 * поэтому в квадратных скобках
			 * указываем i два раза
			 */
			sum += matrix[i][i];
		}

		/*
		 * оператор return завершает выполнение функции и
		 * возвращает управление вызывающей функции,
		 * поэтому return NULL ниже после условного 
		 * оператора if не сработает
		 */

		/*
		 * так как мы будем возвращать результат в
		 * указатель, то передавать в него будем
		 * не значение, а адрес переменной sum
		 */
		return &sum;
	}

	/*
	 * если у нас не квадратная матрица, то
	 * функция возвращает NULL(то есть пустоту)
	 */
	return NULL;
}