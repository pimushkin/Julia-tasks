/*
 * библиотека для работы с выделением
 * динамической памяти и генерацией
 * случайных чисел при помощи
 * фукнции srand
 */
#include <stdlib.h>
#include <stdio.h> // библиотека для работы с выводом на экран(printf)
 /*
  * библиотека для работы с переменными типа данных bool,
  * инициализирующиеся как true или false
  */
#include <stdbool.h>
#include <math.h> // библиотека для работы с фукнцией log10
#include <time.h> // библиотека для работы с функцией time

  /*
   * структура, описывающая компоненту списка
   */
struct Node
{
	/*
	 * ссылка на следующий компонент списка
	 */
	struct Node* next;
	/*
	 * 11-разрядное число
	 */
	char value[11];
};

/*
 * функция для вывода всего списка
 * на экран
 */
void* printList(struct Node* head);
/*
 * функция для создания пустого списка
 */
void* constructNode(struct Node* head);
/*
 * функция для добавления нового компонента в список
 * по принципу очереди(новый элемент хранится в конце)
 */
void* push(struct Node* head, const char* VALUE);
/*
 * функция для поиска указанной
 * цифры в каждом числе списка
 *
 * объявляем как int, а не void, чтобы функция
 * могла pop'нуть первый компонент списка (return pop(head)),
 * если в ней хранится число с не нужной цифрой
 */
int* removeWrongValues(struct Node* head, const char WRONG_FIGURE);
/*
 * функция для удаления компонента из списка тоже
 * по принципу очереди(какой элемент был первым
 * добавлен, то первым и будет удален)
 *
 * используем лишь внутри фукнции removeWrongValues,
 * чтобы удалить первый компонент списка, если
 * она не прошла первую проверку
 */
void* pop(struct Node* head);
/*
 * фукнция для генерации 11-разрядного числа случайного числа,
 * которое формируется из трёх случайных чисел
 */
char* generateValue();
/*
 * функция для перевода числа типа данных int
 * в char (нужна нам, так как наш список хранит все
 * 11-разрядные числа как символьные строки)
 *
 * используем только внутри функции generateValue
 */
char* toArray(int value);

int main()
{
	/*
	 * чтобы получать после каждой отладки новый
	 * список, будем генерировать числа относительно
	 * времени на компьютере
	 */
	srand(time(NULL));

	/*
	 * объявляем список(или же шапку),
	 * который сразу инициализируем как NULL,
	 * потому что он пока что пустой(в шапке
	 * ничего не хранится)
	 */
	struct Node* head = NULL;
	/*
	 * выделяем динамическую память под список
	 */
	head = (struct Node*)malloc(sizeof(struct Node));
	/*
	 * создаем пустой список
	 */
	constructNode(head);

	/*
	 * n - количество чисел, которое будем
	 * добавлять внутрь списка
	 */
	int n = 50;
	/*
	 * чтобы push'ить числа в список, объявляем
	 * переменную tempValue, которая будет в дальнейшем
	 * в себя записывать 3 случайных числа
	 */
	char* tempValue = (char*)malloc(11 * sizeof(char));
	for (int i = 0; i < n; i++)
	{
		/*
		 * функцией generateValue записываем в
		 * tempValue случайное 11-разрядное число
		 */
		tempValue = generateValue();
		/*
		 * push'им новое число внутрь списка
		 */
		push(head, tempValue);
	}

	/*
	 * выводим на экран все числа, добавленные в список
	 */
	printf("Linked list:\n");
	printf("------------\n");
	printList(head);
	printf("\n\n");

	/*
	 * объявляем константу типа int для
	 * передачи внутрь функции по удалению
	 * элементов(removeWrongValues) указанной цифры
	 *
	 * в данном случае цифры 3
	 */
	const char figure = 3;
	/*
	 * вызываем функцию по удалению элементов
	 */
	removeWrongValues(&head, figure);

	/*
	 * выводим на экран новый список
	 */
	printf("New linked list:\n");
	printf("----------------\n");
	printList(head);
	printf("\n");

	system("pause");

	return 0;
}

void* printList(struct Node* head)
{
	/*
	 * создаем копию списка
	 */
	struct Node* current = head;

	int num = 1; // счётчик для нумерации компонент
	/*
	 * до тех пор, пока указатель на следущий компонент
	 * не окажется пустым...
	 */
	while (current->next != NULL)
	{
		/*
		 * ...выводим на экран все элементы из списка
		 */
		printf("%d. ", num);
		for (int i = 0; i < 11; i++)
		{
			printf("%hhi", current->value[i]);
		}
		printf("\n");

		/*
		 * и переходим к следующему компоненту
		 */
		current = current->next;
		num++; // увеличиваем счётчик на единицу
	}
}

void* constructNode(struct Node* head)
{
	struct Node* current = head;

	/*
	 * инициализируем указатель первого компонента на следующий
	 * как пустой, тем самым получаем пустой список
	 */
	current->next = NULL;
}

void* push(struct Node* head, const char* value)
{
	struct Node* current = head;

	/*
	 * перебираем все компоненты в поиске компоненты
	 * с пустым указателем
	 */
	while (current->next != NULL)
	{
		current = current->next;
	}
	/*
	 * как только встретили пустой указатель, то
	 * выделяем память под следующий компонент, ...
	 */
	current->next = malloc(sizeof(struct Node));

	/*
	 * записываем в текующую компоненту элемент,
	 * который передали в функцию
	 */
	for (int i = 0; i < 11; i++)
	{
		current->value[i] = value[i];
	}

	/*
	 * ...а также инициализируем указатель следующего
	 * компонента как пустой
	 */
	current->next->next = NULL;
}

int* removeWrongValues(struct Node** head, const char WRONG_FIGURE)
{
	struct Node* current = *head;

	/*
	 * первый флаг предназначен для проверки того,
	 * что если в элементе первого компонента содержится
	 * ненужная цифра, то в конце функции выполнить pop, тем
	 * самым удалив первый компонент
	 */
	bool flag1 = false;
	/*
	 * первый компонент проверяем вне цикла while,
	 * который распалагается ниже
	 */
	for (int i = 0; i < 11; i++)
	{
		if (current->value[i] == WRONG_FIGURE)
		{
			/*
			 * если встретили ненужную цифру, то
			 * меняем первый флаг на true и выходим из цикла for
			 */
			flag1 = true;
			break;
		}
	}

	while (current->next != NULL)
	{
		/*
		 * второй флаг нужен для проверки того, что мы уже
		 * выполнили один переход на следующую компоненту,
		 * и не выполнять его ещё раз
		 */
		bool flag2 = true;
		for (int i = 0; i < 11; i++)
		{
			/*
			 * проверяем элемент у следующего компонента списка,
			 * и если встретили ненужную цифру внутри элемента, то...
			 */
			if (current->next->value[i] == WRONG_FIGURE)
			{
				/*
				 * ...указатель текующего компомента начинает
				 * указывать на указатель следующего компонента
				 *
				 * хех ¯\_(ツ)_/¯
				 */
				current->next = current->next->next;
				/*
				 * и меняем значение второго флага на false, чтобы при выходе
				 * из цикла for ещё раз не поменять указатель
				 */
				flag2 = false;
				break;
			}
		}
		/*
		 * если второй флаг остался со значением true, то...
		 */
		if (flag2)
		{
			/*
			 * ...выполняем переход к следующему элементу
			 */
			current = current->next;
		}
	}
	/*
	 * если первый флаг принял значение true, то...
	 */
	if (flag1)
	{
		/*
		 * ...pop'аем первую компоненту
		 */
		return pop(head);
	}
}

void* pop(struct Node** head) {
	/*
	 * создаем пустой новый список
	 */
	struct Node* nextNode = NULL;

	/*
	 * если список пустой, то и pop'ать нечего,
	 * поэтому при попытке pop'нуть пустой компонент
	 * выдаем на экран ошибку
	 */
	if (*head == NULL) {
		printf("Error! You cannot remove an empty component.\n\n");
		return 0;
	}
	/*
	 * в новый список добавляем компоненты, начиная со следующей
	 */
	nextNode = (*head)->next;
	/*
	 * очищаем старый список
	 */
	free(*head);
	/*
	 * и старый список делаем новым списком
	 */
	*head = nextNode;
}

char* generateValue()
{
	/*
	 * используем выделение динамической памяти под строки
	 * из цифр, так как функция toArray возвращает динамический
	 * массив(он же в свою очередь используется внутри функции
	 * toArray, так как изначально не определена длина строки)
	 */
	char* value = (char*)malloc(11 * sizeof(char));
	char* chRandom1 = (char*)malloc(4 * sizeof(char));
	char* chRandom2 = (char*)malloc(3 * sizeof(char));

	/*
	 * генерируем случаное число, от которого находим остаток
	 * при делении на 9000, и прибавляем 1000(таким образом
	 * мы получаем всегда 4-разрядное случайное число)
	 */
	int random = rand() % 9000 + 1000;
	/*
	 * так как нельзя переменной типа char явным образом
	 * присвоить переменную типа int, то делаем это с
	 * помощью написанной лично функции toArray
	 */
	chRandom1 = toArray(random);
	/*
	 * начинаем формировать наше число, и добавляем
	 * с 1-ой по 4-ую цифру
	 */
	for (int j = 0; j < 4; j++)
	{
		value[j] = chRandom1[j];
	}

	random = rand() % 9000 + 1000;
	chRandom1 = toArray(random);
	/*
	 * ...c 5-ой по 8-ую цифру
	 */
	for (int j = 4; j < 8; j++)
	{
		value[j] = chRandom1[j - 4];
	}

	random = rand() % 900 + 100;
	chRandom2 = toArray(random);
	/*
	 * ...c 9-ой по 11-ую цифру
	 */
	for (int j = 8; j < 11; j++)
	{
		value[j] = chRandom2[j - 8];
	}

	/*
	 * возвращаем сформировавшееся число
	 * при помощи оператора return
	 */
	return value;
}

char* toArray(int value)
{
	/*
	 * находим десятичный логарифм от добавленного числа
	 * и прабавляем единицу, таким образом получаем
	 * разрядность переданного в функцию числа
	 */
	int n = log10(value) + 1;
	/*
	 * выдялем данамическую память под массив типа char,
	 * в который будем добавлять новое число по одной цифре
	 */
	char* numberArray = (char*)malloc(n * sizeof(char));
	/*
	 * так как цифру будем отсекать с конца и добавлять тоже
	 * в конец массива, то цикл начинаем с "n - 1" по 0 включительно
	 *
	 * value /= 10, чтобы уменьшать разрядность числа,
	 * переданного в функцию toArray, на единицу после
	 * каждой итерации
	 */
	for (int i = n - 1; i >= 0; i--, value /= 10)
	{
		/*
		 * присваиваем текущему элементу массива
		 * последнюю цифру от value
		 */
		numberArray[i] = value % 10;
	}
	return numberArray;
}